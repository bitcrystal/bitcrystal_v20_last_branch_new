#define PLH__ASMHelper__D_INT64 8
#define PLH__ASMHelper__D_INT32 4
#define PLH__ASMHelper__D_INT16 2
#define PLH__ASMHelper__D_INT8 1
#define PLH__ASMHelper__D_INVALID -1

int8_t PLH__ASMHelper__GetDisplacementType(const uint8_t DispVal)
{
	switch (DispVal)
	{
		case PLH__ASMHelper__D_INT8:
			return PLH__ASMHelper__D_INT8;
		case PLH__ASMHelper__D_INT16:
			return PLH__ASMHelper__D_INT16;
		case PLH__ASMHelper__D_INT32:
			return PLH__ASMHelper__D_INT32;
		case PLH__ASMHelper__D_INT64:
			return PLH__ASMHelper__D_INT64;
		default:
			return PLH__ASMHelper__D_INVALID;
	}
}

BOOL PLH__ASMHelper__IsConditionalJump(const BYTE* bytes,const uint16_t Size)
{
	//http://unixwiz.net/techtips/x86-jumps.html
	if (Size < 1)
		return TRUE;

	if (bytes[0] == 0x0F && Size > 1)
	{
		if (bytes[1] >= 0x80 && bytes[1] <= 0x8F)
			return TRUE;
	}

	if (bytes[0] >= 0x70 && bytes[0] <= 0x7F)
		return TRUE;

	if (bytes[0] == 0xE3)
		return TRUE;

	return FALSE;
}

int8_t PLH__ASMHelper__GetDisplacement__int8_t(BYTE* Instruction, const uint32_t Offset)
{
	int8_t Disp;
	memset(&Disp, 0x00, sizeof(int8_t));
	memcpy(&Disp, &Instruction[Offset], sizeof(int8_t));
	return Disp;
}

int16_t PLH__ASMHelper__GetDisplacement__int16_t(BYTE* Instruction, const uint32_t Offset)
{
	int16_t Disp;
	memset(&Disp, 0x00, sizeof(int16_t));
	memcpy(&Disp, &Instruction[Offset], sizeof(int16_t));
	return Disp;
}

int32_t PLH__ASMHelper__GetDisplacement__int32_t(BYTE* Instruction, const uint32_t Offset)
{
	int32_t Disp;
	memset(&Disp, 0x00, sizeof(int32_t));
	memcpy(&Disp, &Instruction[Offset], sizeof(int32_t));
	return Disp;
}

typedef enum _PLH__ASMHelper__HookType
{
	X86Detour,
	X64Detour,
	UNKNOWN
} PLH__ASMHelper__HookType;

typedef struct _PLH_ABSTRACT_DETOUR_S
{
	HANDLE m_CapstoneHandle;
	BYTE * m_hkSrc;
	BYTE * m_hkDst;
	BYTE * m_hkLength;
	BYTE * m_NeedFree;
	PLH__ASMHelper__HookType plhAsmHelperHookType;
} PLH_ABSTRACT_DETOUR_S;

typedef struct _PLH_X86_DETOUR_S
{
	
} PLH_X86_DETOUR_S;

typedef struct _PLH_X64_DETOUR_S
{
	
} PLH_X64_DETOUR_S;

typedef struct _PLH_ALL_S 
{
	PLH_ABSTRACT_DETOUR_S plhAbstractDetourS;
	PLH_X86_DETOUR_S plhX86DetourS;
	PLH_X64_DETOUR_S plhX64DetourS;
} PLH_ALL_S;

void PLH__MyDetour__Init(PLH_ALL_S*a)
{
	if(a==0)
	{
		return;
	}
	memset(a,0,sizeof(PLH_ALL_S));
	
}

HANDLE PLH__MyDetour__GetCapstoneHandle(PLH_ALL_S*a)
{
	if(a==0)
		return 0;
	return a->plhAbstractDetourS->m_CapstoneHandle;
}

void PLH__MyDetour__SetCapstoneHandle(PLH_ALL_S*a,HANDLE capstoneHandle)
{
	if(a==0)
		return;
	a->plhAbstractDetourS->m_CapstoneHandle=capstoneHandle;
}

void PLH__MyDetour__SetCapstoneHandle(PLH_ALL_S*a,HANDLE capstoneHandle)
{
	if(a==0)
		return;
	a->plhAbstractDetourS->m_CapstoneHandle=capstoneHandle;
}

void PLH__AbstractDetour__RelocateASM(PLH_ALL_S*a,BYTE* Code, DWORD& CodeSize, DWORD64 From, DWORD64 To)
{
	cs_insn* InstructionInfo;
	size_t InstructionCount = cs_disasm(PLH__MyDetour__GetCapstoneHandle(a), Code, CodeSize, (uint64_t)Code, 0, &InstructionInfo);

	XTrace("\nTrampoline:\n");
	for (int i = 0; i < InstructionCount; i++)
	{
		cs_insn* CurIns = (cs_insn*)&InstructionInfo[i];
		cs_x86* x86 = &(CurIns->detail->x86);

		XTrace("%I64X: ", CurIns->address);
		for (int j = 0; j < CurIns->size; j++)
			XTrace("%02X ", CurIns->bytes[j]);
		XTrace("%s %s\n", CurIns->mnemonic,CurIns->op_str);

		for (int j = 0; j < x86->op_count; j++)
		{
			cs_x86_op* op = &(x86->operands[j]);
			if (op->type == X86_OP_MEM)
			{
				//MEM are types like lea rcx,[rip+0xdead]
				if (op->mem.base == X86_REG_INVALID)
					continue;

				//Are we relative to instruction pointer?
				if (op->mem.base != GetIpReg())
					continue;

				PLH__AbstractDetour__Relocate(CurIns, From, To, x86->offsets.displacement_size, x86->offsets.displacement_offset);
			}else if (op->type == X86_OP_IMM) {
				//IMM types are like call 0xdeadbeef
				if (x86->op_count > 1) //exclude types like sub rsp,0x20
					continue;

				
				char* mnemonic = CurIns->mnemonic;
				if (PLH__ASMHelper__IsConditionalJump(CurIns->bytes,CurIns->size))
				{
					PLH__AbstractDetour__RelocateConditionalJMP(CurIns, CodeSize, From, To, x86->offsets.imm_size, x86->offsets.imm_offset);
					continue;
				}

				//types like push 0x20 slip through, check mnemonic
				if (strcmp(mnemonic, "call") != 0 && strcmp(mnemonic, "jmp") != 0) //probably more types than just these, update list as they're found
					continue;

				PLH__AbstractDetour__Relocate(CurIns, From, To, x86->offsets.imm_size, x86->offsets.imm_offset);
			}
		}
	}

	XTrace("\nFixed Trampoline\n");
	InstructionCount = cs_disasm(PLH__MyDetour__GetCapstoneHandle(a), Code, CodeSize, (uint64_t)Code, 0, &InstructionInfo);
	for (int i = 0; i < InstructionCount; i++)
	{
		cs_insn* CurIns = (cs_insn*)&InstructionInfo[i];

		XTrace("%I64X: ", CurIns->address);
		for (int j = 0; j < CurIns->size; j++)
			XTrace("%02X ", CurIns->bytes[j]);
		XTrace("%s %s\n", CurIns->mnemonic, CurIns->op_str);
	}
	cs_free(InstructionInfo, InstructionCount);
}

void PLH__AbstractDetour__Relocate(PLH_ALL_S*a,cs_insn* CurIns, DWORD64 From, DWORD64 To, const uint8_t DispSize, const uint8_t DispOffset)
{
	//XTrace("Relocating...\n");

	int8_t DispType = PLH__ASMHelper__GetDisplacementType(DispSize);
	if (DispType == PLH__ASMHelper__D_INT8)
	{
		int8_t Disp = PLH__ASMHelper__GetDisplacement_int8_t(CurIns->bytes, DispOffset);
		Disp -= (To - From);
		*(int8_t*)(CurIns->address + DispOffset) = Disp;
	}else if (DispType == PLH__ASMHelper__D_INT16) {
		int16_t Disp = PLH__ASMHelper__GetDisplacement_int16_t(CurIns->bytes, DispOffset);
		Disp -= (To - From);
		*(int16_t*)(CurIns->address + DispOffset) = Disp;
	}else if (DispType == PLH__ASMHelper__D_INT32) {
		int32_t Disp = PLH__ASMHelper__GetDisplacement_int32_t(CurIns->bytes, DispOffset);
		Disp -= (To - From);
		*(int32_t*)(CurIns->address + DispOffset) = Disp;
	}
}

void PLH__AbstractDetour__Initialize(PLH_ALL_S*a,cs_mode Mode)
{
	if (cs_open(CS_ARCH_X86, Mode, &(PLH__MyDetour__GetCapstoneHandle(a))) != CS_ERR_OK)
		//XTrace("Error Initializing Capstone x86\n");

	cs_option(PLH__MyDetour__GetCapstoneHandle(a), CS_OPT_DETAIL, CS_OPT_ON);
}

DWORD PLH__AbstractDetour__CalculateLength(PLH_ALL_S*a,BYTE* Src, DWORD NeededLength)
{
	//Grab First 100 bytes of function, disasm until invalid instruction
	cs_insn* InstructionInfo;
	size_t InstructionCount = cs_disasm(PLH__MyDetour__GetCapstoneHandle(a), Src, 0x100, (uint64_t)Src, 0, &InstructionInfo);

	//Loop over instructions until we have at least NeededLength's Size
	//XTrace("\nORIGINAL:\n");
	DWORD InstructionSize = 0;
	bool BigEnough = false;
	for (int i = 0; i < InstructionCount && !BigEnough; i++)
	{
		cs_insn* CurIns = (cs_insn*)&InstructionInfo[i];
		InstructionSize += CurIns->size;
		if (InstructionSize >= NeededLength)
			BigEnough = true;

		//XTrace("%I64X [%d]: ", CurIns->address, CurIns->size);
		for (int j = 0; j < CurIns->size; j++)
			//XTrace("%02X ", CurIns->bytes[j]);
		//XTrace("%s %s\n", CurIns->mnemonic, CurIns->op_str);
	}
	if (!BigEnough)
		InstructionSize = 0;

	cs_free(InstructionInfo, InstructionCount);
	return InstructionSize;
}

void PLH__AbstractDetour__RelocateConditionalJMP(PLH_ALL_S*a,cs_insn* CurIns, DWORD& CodeSize, DWORD64 From, DWORD64 To, const uint8_t DispSize, const uint8_t DispOffset)
{
	/*This function automatically begins to build a jump table at the end of the trampoline to allow relative jumps to function properly:
	-Changes relative jump to point to an absolute jump
	-Absolute jump then does the long distance to jump to where the relative jump originally went
	*/
	int8_t DispType = PLH__ASMHelper__GetDisplacementType(DispSize);
	DWORD64 TrampolineEnd = To + CodeSize;
	if (DispType == PLH__ASMHelper__D_INT8)
	{
		int8_t Disp = PLH__ASMHelper__GetDisplacement__int8_t(CurIns->bytes, DispOffset);
		DWORD64 OriginalDestination = CurIns->address + (Disp - (To - From)) + CurIns->size;
		PLH__AbstractDetour__WriteJMP(TrampolineEnd, OriginalDestination);
		Disp = PLH__AbstractDetour__CalculateRelativeDisplacement__int8_t(CurIns->address, (DWORD64)TrampolineEnd, CurIns->size); //set relative jmp to go to our absolute
		*(int8_t*)(CurIns->address + DispOffset) = Disp;
		CodeSize += PLH__AbstractDetour__GetJMPSize();
	}else if (DispType == PLH__ASMHelper__D_INT16) {
		int16_t Disp = Disp = PLH__ASMHelper__GetDisplacement__int16_t(CurIns->bytes, DispOffset);
		DWORD64 OriginalDestination = CurIns->address + (Disp - (To - From)) + CurIns->size;
		PLH__AbstractDetour__WriteJMP(TrampolineEnd, OriginalDestination);
		Disp = PLH__AbstractDetour__CalculateRelativeDisplacement__int16_t(CurIns->address, (DWORD64)TrampolineEnd, CurIns->size);
		*(int16_t*)(CurIns->address + DispOffset) = Disp;
		CodeSize += PLH__AbstractDetour__GetJMPSize();
	}else if (DispType == PLH__ASMHelper__D_INT32) {
		int32_t Disp = PLH__ASMHelper__GetDisplacement__int32_t(CurIns->bytes, DispOffset);
		DWORD64 OriginalDestination = CurIns->address + (Disp - (To - From)) + CurIns->size;
		PLH__AbstractDetour__WriteJMP(TrampolineEnd, OriginalDestination);
		Disp = PLH__AbstractDetour__CalculateRelativeDisplacement__int32_t(CurIns->address, (DWORD64)TrampolineEnd, CurIns->size);
		*(int32_t*)(CurIns->address + DispOffset) = Disp;
		CodeSize += PLH__AbstractDetour__GetJMPSize();
	}
}

PLH__AbstractDetour__deinit(PLH_ALL_S*a)
{
	cs_close(&(PLH__MyDetour__GetCapstoneHandle(a)));
}

void PLH__AbstractDetour__SetupHook(PLH_ALL_S*a,BYTE* Src, BYTE* Dest)
{
	m_hkSrc = Src;
	m_hkDest = Dest;
}

void PLH__AbstractDetour__UnHook(PLH_ALL_S*a)
{
	MemoryProtect Protector(m_hkSrc, m_hkLength, PAGE_EXECUTE_READWRITE);
	memcpy(m_hkSrc, m_OriginalCode, m_OriginalLength); //Copy original from trampoline back to src
	FlushSrcInsCache();
	FreeTrampoline();
}

PLH__AbstractDetour__init(PLH_ALL_S*a)
{
#ifdef _WIN64
	Initialize(CS_MODE_64);
#else
	Initialize(CS_MODE_32);
#endif // _WIN64
}

void PLH__X86Detour__WriteRelativeJMP(PLH_ALL_S*a,DWORD Destination, DWORD JMPDestination)
{
	*(BYTE*)Destination = 0xE9;       //Write jump opcode to jump back to non overwritten code
	*(long*)(Destination + 1) = PLH__X86Detour__CalculateRelativeDisplacement_long(Destination, JMPDestination, 5);
}

void PLH__X86Detour__WriteJMP(PLH_ALL_S*a,DWORD_PTR From, DWORD_PTR To)
{
	PLH__X86Detour__WriteRelativeJMP(From, To);
}

int PLH__X86Detour__GetJMPSize()
{
	return 5;
}

#ifndef _WIN64
PLH__X86Detour__init(PLH_ALL_S*a)
{

}

PLH__X86Detour__deinit(PLH_ALL_S*a)
{
	if (m_NeedFree)
		delete[] m_Trampoline;
}

PLH__ASMHelper__HookType PLH__X86Detour__GetType(PLH_ALL_S*a)
{
	return PLH__ASMHelper__HookType::X86Detour;
}

bool PLH__X86Detour__Hook(PLH_ALL_S*a)
{
	DWORD OldProtection;

	m_hkLength = PLH__X86Detour__CalculateLength(m_hkSrc, 5);
	m_OriginalLength = m_hkLength;
	if (m_hkLength == 0)
	{
		XTrace("Function to small to hook\n");
		return false;
	}

	m_Trampoline = new BYTE[m_hkLength + 30];   //Allocate Space for original plus extra to jump back and for jmp table
	m_NeedFree = true;
	VirtualProtect(m_Trampoline, m_hkLength + 5, PAGE_EXECUTE_READWRITE, &OldProtection); //Allow Execution
	
	memcpy(m_OriginalCode, m_hkSrc, m_hkLength);
	memcpy(m_Trampoline, m_hkSrc, m_hkLength); //Copy original into allocated space
	PLH__X86Detour__RelocateASM(m_Trampoline, m_hkLength, (DWORD)m_hkSrc, (DWORD)m_Trampoline);
	PLH__X86Detour__WriteRelativeJMP((DWORD)&m_Trampoline[m_hkLength], (DWORD)m_hkSrc + m_hkLength); //JMP back to original code

	//Change protection to allow write on original function
	MemoryProtect Protector(m_hkSrc, m_hkLength, PAGE_EXECUTE_READWRITE);
	//Encode Jump from Hooked Function to the Destination function
	PLH__X86Detour__WriteRelativeJMP((DWORD)m_hkSrc, (DWORD)m_hkDest);

	//Write nops over bytes of overwritten instructions
	for (int i = 5; i < m_OriginalLength; i++)
		m_hkSrc[i] = 0x90;
	FlushSrcInsCache();

	//PostError(RuntimeError(RuntimeError::Severity::Warning, "PolyHook x86Detour: Some opcodes may not be relocated properly"));
	return true;
	/*Original
	-JMP Destination
	-NOP (extends to length of overwritten opcode)
	-Rest of function

	Destination
	-Do your shit
	-Return Trampoline (goes to trampoline)

	Trampoline
	-Execute Overwritten Opcodes
	-Patch original relative jmps to point to jump table (JE Jumptable entry 1)
	-JMP to rest of function (in original)
	-*BEGIN JUMPTABLE*
	-1)JMP to location of relative jmp one
	-2)...continue pattern for all relative jmps
	*/
}

x86_reg PLH__X86Detour__GetIpReg(PLH_ALL_S*a)
{
	return X86_REG_EIP;
}

void PLH__X86Detour__FreeTrampoline(PLH_ALL_S*a)
{
	if (m_NeedFree)
	{
		delete[] m_Trampoline;
		m_NeedFree = false;
	}
}

void PLH__X86Detour__WriteRelativeJMP(PLH_ALL_S*a,DWORD Destination, DWORD JMPDestination)
{
	*(BYTE*)Destination = 0xE9;       //Write jump opcode to jump back to non overwritten code
	*(long*)(Destination + 1) = PLH__X86Detour__CalculateRelativeDisplacement_long(Destination, JMPDestination, 5);
}

void PLH__X86Detour__WriteJMP(PLH_ALL_S*a,DWORD_PTR From, DWORD_PTR To)
{
	PLH__X86Detour__WriteRelativeJMP(From, To);
}

int PLH__X86Detour__GetJMPSize(PLH_ALL_S*a)
{
	return 5;
}

PLH__X64Detour__init(PLH_ALL_S*a)
{

}

PLH__X64Detour__deinit(PLH_ALL_S*a)
{
	PLH__X64Detour__FreeTrampoline(PLH_ALL_S*a);
}

PLH__ASMHelper__HookType PLH__X64Detour__GetType()
{
	return PLH__ASMHelper__HookType::X64Detour;
}

bool PLH__X64Detour__Hook(PLH_ALL_S*a)
{
	//Allocate Memory as close as possible to src, to minimize chance 32bit displacements will be out of range (for relative jmp type)
	MEMORY_BASIC_INFORMATION mbi;
	for (size_t Addr = (size_t)m_hkSrc; Addr > (size_t)m_hkSrc - 0x80000000; Addr = (size_t)mbi.BaseAddress - 1)
	{
		if (!VirtualQuery((LPCVOID)Addr, &mbi, sizeof(mbi)))
			break;

		if (mbi.State != MEM_FREE)
			continue;

		if (m_Trampoline = (BYTE*)VirtualAlloc(mbi.BaseAddress, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE))
			break;
	}
	if (!m_Trampoline)
		return false;
	m_NeedFree = true;

	//Decide which jmp type to use based on function size
	bool UseRelativeJmp = false;
	m_hkLength = PLH__X64Detour__CalculateLength(m_hkSrc, 16); //More stable 16 byte jmp
	m_OriginalLength = m_hkLength; //We modify hkLength in Relocation routine
	if (m_hkLength == 0)
	{
		UseRelativeJmp = true;
		m_hkLength = PLH__X64Detour__CalculateLength(m_hkSrc, 6); //Smaller, less safe 6 byte (jmp could be out of bounds)
		if (m_hkLength == 0)
		{
			//PostError(RuntimeError(RuntimeError::Severity::UnRecoverable, "PolyHook x64Detour: Function to small to hook"));
			return false;
		}
	}

	memcpy(m_OriginalCode, m_hkSrc, m_hkLength);
	memcpy(m_Trampoline, m_hkSrc, m_hkLength);
	PLH__X64Detour__RelocateASM(m_Trampoline,m_hkLength, (DWORD64)m_hkSrc, (DWORD64)m_Trampoline);
	//Write the jmp from our trampoline back to the original
	PLH__X64Detour__WriteAbsoluteJMP((DWORD64)&m_Trampoline[m_hkLength], (DWORD64)m_hkSrc + m_hkLength); 

	// Build a far jump to the Destination function. (jmps not to address pointed at but to the value in the address)
	MemoryProtect Protector(m_hkSrc, m_hkLength, PAGE_EXECUTE_READWRITE);
	int HookSize = 0;
	if (UseRelativeJmp)
	{
		HookSize = 6;
		m_hkSrc[0] = 0xFF;
		m_hkSrc[1] = 0x25;
		//Write 32Bit Displacement from rip
		*(long*)(m_hkSrc + 2) = CalculateRelativeDisplacement_long((DWORD64)m_hkSrc, (DWORD64)&m_Trampoline[m_hkLength + 16], 6);
		*(DWORD64*)&m_Trampoline[m_hkLength + 16] = (DWORD64)m_hkDest; //Write the address into memory at [RIP+Displacement]
	}else {
		HookSize = 16;
		PLH__X64Detour__WriteAbsoluteJMP((DWORD64)m_hkSrc, (DWORD64)m_hkDest);
	}
	//Nop Extra bytes from overwritten opcode
	for (int i = HookSize; i < m_OriginalLength; i++)
		m_hkSrc[i] = 0x90;

	FlushInstructionCache(GetCurrentProcess(), m_hkSrc, m_hkLength);
	//PostError(RuntimeError(RuntimeError::Severity::Warning, "PolyHook x64Detour: Relocation can be out of range"));
	return true;
}

x86_reg PLH__X64Detour__GetIpReg(PLH_ALL_S*a)
{
	return X86_REG_RIP;
}

void PLH__X64Detour__FreeTrampoline(PLH_ALL_S*a)
{
	if (m_NeedFree)
	{
		VirtualFree(m_Trampoline, 0, MEM_RELEASE);
		m_NeedFree = false;
	}
}

void PLH__X64Detour__WriteAbsoluteJMP(PLH_ALL_S*a,DWORD64 Destination, DWORD64 JMPDestination)
{
	/*push rax
	mov rax ...   //Address to original
	xchg qword ptr ss:[rsp], rax
	ret*/
	BYTE detour[] = { 0x50, 0x48, 0xB8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x87, 0x04, 0x24, 0xC3 };
	memcpy((BYTE*)Destination, detour, sizeof(detour));
	*(DWORD64*)&((BYTE*)Destination)[3] = JMPDestination;
}

void PLH__X64Detour__WriteJMP(PLH_ALL_S*a,DWORD_PTR From, DWORD_PTR To)
{
	PLH__X64Detour__WriteAbsoluteJMP(a,From, To);
}

int PLH::X64Detour::GetJMPSize(PLH_ALL_S*a)
{
	return 16;
}
#endif
